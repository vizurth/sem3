\section{Особенности реализации}

\subsection{Структура проекта}

Проект имеет следующую структуру: 
\begin{itemize}
    \item \texttt{SmallArithmetic.hpp} и \texttt{SmallArithmetic.cpp}: содержат реализацию малой конечной арифметики на основе диаграммы Хассе.  Класс выполняет операции над однозначными элементами алфавита.
    
    \item \texttt{BigArithmeticCalc.hpp} и \texttt{BigArithmeticCalc.cpp}: содержат реализацию большой конечной арифметики. Класс выполняет операции столбиком над многозначными числами.
    
    \item \texttt{UI.hpp} и \texttt{UI.cpp}:  реализуют пользовательский интерфейс, обработку команд и арифметических выражений. 
    
    \item \texttt{config.hpp}: содержит конфигурацию системы - мощность алфавита, правило "$+1$" и сам алфавит.
    
    \item \texttt{main.cpp}: точка входа в программу. 
    
    \item \texttt{CMakeLists.txt}: автоматизация сборки проекта.
\end{itemize}

\subsection{Структуры данных}

Для реализации конечной арифметики используются два класса: \texttt{SmallArithmetic} и \texttt{BigArithmeticCalc}. 

\subsubsection{Класс SmallArithmetic}

Класс хранит следующие основные структуры: 
\begin{itemize}
    \item \texttt{map<string, string> plusOneRule}:  правило перехода к следующему элементу алфавита. 
    
    \item \texttt{vector<string> alphabet}:  набор всех элементов алфавита. 
    
    \item \texttt{map<string, string> inverseMap}: таблица обратных элементов для деления.
    
    \item \texttt{map<tuple<string, string, string>, pair<string, string>>
additionTableWithCarry}: таблица сложения с переносом для операций столбиком.
    
    \item \texttt{vector<vector<string>> addTable, mulTable, subTable, divTable}: таблицы операций малой арифметики.
    
    \item \texttt{int N}: мощность алфавита. 
    
    \item \texttt{static const int MAX\_DIGITS = 8}: максимальное количество разрядов в числах.
\end{itemize}

\subsubsection{Класс BigArithmeticCalc}

Класс содержит: 
\begin{itemize}
    \item \texttt{SmallArithmetic small}: объект малой арифметики для выполнения посимвольных операций. 
\end{itemize}
\subsection{Класс SmallArithmetic}

\subsubsection{Назначение и структура данных}

Класс \texttt{SmallArithmetic} реализует малую конечную арифметику на заданном алфавите с правилом перехода к следующему элементу (правило "$+1$"). Все операции выполняются через построение диаграммы Хассе.

\begin{lstlisting}[style=cstyle, caption={Интерфейс класса SmallArithmetic}]
class SmallArithmetic {
private:
    int N;
    map<string, string> plusOneRule;
    vector<string> alphabet;

    map<string, string> inverseMap;

    map<tuple<string, string, string>, pair<string, string>> additionTableWithCarry;
    map<string, string> negationMap;

    vector<vector<string>> addTable;
    vector<vector<string>> mulTable;
    vector<vector<string>> subTable;
    vector<vector<string>> divTable;

    string additiveIdentity;
    string multiplicativeIdentity;
    string universum;
    string emptySet;

    static const int MAX_DIGITS = 8;

    string addByHasse(const string& a, const string& b) const;
    string multiplyByHasse(const string& a, const string& b) const;
    string subtractByHasse(const string& a, const string& b) const;
    string divideByHasse(const string& a, const string& b) const;

    optional<string> findMultiplicativeInverse(const string& x);
    void buildInverseMap();

    void buildAddTable();
    void buildMulTable();
    void buildSubTable();
    void buildDivTable();

    void buildAdditionTableWithCarry();
    bool checkCarry(const string& start, const string& steps) const;
    void buildNegationMap();

    string nextSymbol(const string& current) const;
    int compareSymbols(const string& a, const string& b) const;

    void printTable(const vector<vector<string>>& table) const;

public:
    SmallArithmetic(int n,
                    const map<string, string>& rule,
                    const vector<string>& alph,
                    const string& addId = "a",
                    const string& mulId = "b");

    const vector<string>& getAlphabet() const;
    int getN() const;

    const string& getAdditiveIdentity() const;
    const string& getMultiplicativeIdentity() const;
    const string& getUniversum() const;
    const string& getEmptySet() const;
    int getMaxDigits() const;
    string getMinNumber() const;
    string getMaxNumber() const;

    bool isValidElement(const string& elem) const;
    int compareElems(const string& a, const string& b) const;
    string nextElem(const string& current) const;
    pair<string, string> addWithCarry(const string& c1,
                                      const string& c2,
                                      const string& carry_in) const;
    string smallSubtract(const string& a, const string& b) const;

    void printAddTable() const;
    void printMulTable() const;
    void printSubTable() const;
    void printDivTable() const;
    void printAllTables() const;
    void printHasseDiagram() const;
};


\end{lstlisting}

\subsection*{Ключевые методы}

\subsubsection{Метод nextSymbol(const string\& current)}

\textbf{Назначение:} Возвращает следующий элемент алфавита согласно правилу "$+1$".  Используется для обхода диаграммы Хассе при выполнении операций сложения и умножения. 

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& current}:  Текущий символ алфавита.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}:  Следующий символ по правилу "$+1$". 
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация nextSymbol()}]
string SmallArithmetic::nextSymbol(const string& current) const {
    auto it = plusOneRule.find(current);
    if (it == plusOneRule.end()) {
        throw runtime_error("invalid symbol: " + current);
    }
    return it->second;
}
\end{lstlisting}

\newpage

\subsubsection{Метод compareSymbols(const string\& a, const string\& b)}

\textbf{Назначение:} Сравнивает два элемента алфавита, определяя их относительный порядок в диаграмме Хассе.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}: Первый элемент для сравнения. 
    \item \texttt{const string\& b}: Второй элемент для сравнения.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{int}: $0$ (если $a = b$), $-1$ (если $a < b$), $1$ (если $a > b$).
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация compareSymbols()}]
int SmallArithmetic::compareSymbols(const string& a, const string& b) const {
    if (a == b) return 0;

    string current = additiveIdentity;
    while (true) {
        if (current == a) return -1;
        if (current == b) return 1;
        current = nextSymbol(current);
        if (current == additiveIdentity) break;
    }
    return 0;
}
\end{lstlisting}

Алгоритм последовательно проходит по циклу правила "$+1$", начиная с нейтрального элемента, и определяет, какой из элементов встречается раньше.

\subsubsection{Метод addByHasse(const string\& a, const string\& b)}

\textbf{Назначение:} Выполняет сложение двух элементов алфавита путём последовательного применения правила "$+1$".  Результат вычисляется как $a + b = \underbrace{(a +1) +1 \ldots +1}_{b \text{ раз}}$. 

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}:  Первое слагаемое.
    \item \texttt{const string\& b}: Второе слагаемое.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}:  Результат сложения $a + b$.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация addByHasse()}]
string SmallArithmetic::addByHasse(const string& a, const string& b) const {
    if (b == additiveIdentity) return a;

    string counter = additiveIdentity;
    string result = a;

    while (counter != b) {
        result = nextSymbol(result);
        counter = nextSymbol(counter);
    }

    return result;
}
\end{lstlisting}

Алгоритм работает следующим образом:
\begin{enumerate}
    \item Если второе слагаемое является нейтральным элементом, возвращается первое слагаемое;
    \item Инициализируется счётчик нейтральным элементом;
    \item В цикле счётчик увеличивается до значения второго слагаемого;
    \item Одновременно результат увеличивается на ту же величину;
    \item Возвращается итоговое значение.
\end{enumerate}

\newpage

\subsubsection{Метод multiplyByHasse(const string\& a, const string\& b)}

\textbf{Назначение:} Выполняет умножение двух элементов алфавита через повторное сложение. Результат вычисляется как $a \times b = \underbrace{a + a + \ldots + a}_{b \text{ раз}}$. 

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}:  Множитель.
    \item \texttt{const string\& b}:  Множитель.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}: Результат умножения $a \times b$.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация multiplyByHasse()}]
string SmallArithmetic::multiplyByHasse(const string& a, const string& b) const {
    // специальный случай: a * a = универсум
    if (a == additiveIdentity && b == additiveIdentity) {
        return universum;
    }

    if (a == additiveIdentity || b == additiveIdentity) {
        return additiveIdentity;
    }

    string counter = additiveIdentity;
    string result = additiveIdentity;

    // буквенный счетчик
    while (counter != b) {
        result = addByHasse(result, a);
        counter = nextSymbol(counter);
    }

    return result;
}
\end{lstlisting}

Алгоритм: 
\begin{enumerate}
    \item Обработка краевого случая:  произведение двух нейтральных элементов по сложению даёт универсум;
    \item Если хотя бы один множитель - нейтральный элемент, результат - нейтральный элемент;
    \item Иначе выполняется повторное сложение множимого с самим собой $b$ раз. 
\end{enumerate}

\subsubsection{Метод subtractByHasse(const string\& a, const string\& b)}

\textbf{Назначение:} Выполняет вычитание путём поиска такого элемента $c$, что $b + c = a$. Реализует обратную операцию к сложению.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}: Уменьшаемое. 
    \item \texttt{const string\& b}: Вычитаемое.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}:  Результат вычитания $a - b$ или строка ошибки.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация subtractByHasse()}]
string SmallArithmetic::subtractByHasse(const string& a, const string& b) const {
    for (const auto& candidate : alphabet) {
        if (addByHasse(b, candidate) == a) {
            return candidate;
        }
    }
    return "ERR:  with subtract";
}
\end{lstlisting}

Алгоритм перебирает все элементы алфавита и проверяет, какой из них при сложении с вычитаемым даёт уменьшаемое. 

\newpage


\subsubsection{Метод buildAdditionTableWithCarry()}

\textbf{Назначение:} Строит таблицу для сложения с учётом входящего переноса. Таблица используется в большой арифметике при сложении столбиком.  Для каждой тройки $(a, b, c_{in})$ вычисляется пара $(sum, c_{out})$.

\textbf{Вход:}
\begin{itemize}
    \item vector<string> alphabet
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item map<tuple<string, string, string>, pair<string, string>> additionTableWithCarry - таблица для сложения с учётом входящего переноса.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация buildAdditionTableWithCarry()}]
void SmallArithmetic::buildAdditionTableWithCarry() {
    for (const auto& c1 : alphabet) {
        for (const auto& c2 : alphabet) {
            for (const auto& carry_in : {additiveIdentity, multiplicativeIdentity}) {
                string sum1 = addByHasse(c1, c2); // сумма без переноса
                string final_sum = addByHasse(sum1, carry_in); // финальная сумма с учетом переноса

                bool carry1 = checkCarry(c1, c2); // проверяем перенос с1 + с2
                bool carry2 = checkCarry(sum1, carry_in); // проверяем перенос sum1 + carry_in

                string carry_out = (carry1 || carry2) ? multiplicativeIdentity : additiveIdentity; // выставляем перенос

                additionTableWithCarry[make_tuple(c1, c2, carry_in)] = make_pair(final_sum, carry_out);
            }
        }
    }
}
\end{lstlisting}

Таблица содержит тройки $(a, b, c_{in})$ и соответствующие им пары $(sum, c_{out})$, где: 
\begin{itemize}
    \item $a, b$ - слагаемые разрядов;
    \item $c_{in}$ - входящий перенос из младшего разряда;
    \item $sum$ - результат сложения в текущем разряде;
    \item $c_{out}$ - исходящий перенос в старший разряд.
\end{itemize}

\newpage

\subsection{Класс BigArithmeticCalc}

\subsubsection{Назначение и структура данных}

Класс \texttt{BigArithmeticCalc} реализует большую конечную арифметику - операции над многозначными числами. Внутри использует класс \texttt{SmallArithmetic} для посимвольных операций.



\begin{lstlisting}[style=cstyle, caption={Интерфейс класса BigArithmeticCalc}]
class BigArithmeticCalc {
private:
    SmallArithmetic small;

    bool isNegative(const string& num) const;
    string removeSign(const string& num) const;
    string addSign(const string& num, bool negative) const;
    
    bool isValidNumber(const string& num) const;
    
    string deleteTrashZeros(const string& num) const;
    
    bool isOverflow(const string& num) const;

    string addBigUnsigned(const string& a, const string& b) const;
    string subtractBigUnsigned(const string& a, const string& b) const;
    string multiplyBigUnsigned(const string& a, const string& b) const;
    pair<string, string> divideBigUnsigned(const string& a, const string& b) const;
    
    string multiplyByDigit(const string& num, const string& digit) const;
    
    int compareBigUnsigned(const string& a, const string& b) const;
    
public:
    BigArithmeticCalc(int n, 
                      const map<string, string>& rule, 
                      const vector<string>& alph,
                      const string& addId = "a",
                      const string& mulId = "b");
    
    const vector<string>& getAlphabet() const;
    string getMinNumber() const;
    string getMaxNumber() const;
    
    string add(const string& a, const string& b) const;
    string multiply(const string& a, const string& b) const;
    string subtract(const string& a, const string& b) const;
    string divide(const string& a, const string& b) const; 
    
    void printAddTable() const;
    void printMulTable() const;
    void printSubTable() const;
    void printDivTable() const;
    void printAllTables() const;
    void printInfo() const;
    void printHasseDiagram() const;
    void printHelp() const;
};
\end{lstlisting}

Класс хранит только один объект малой арифметики, через который выполняются все операции с разрядами.

\subsection*{Вспомогательные методы}

\subsubsection{Метод isNegative(const string\& num)}

\textbf{Назначение:} Проверяет, является ли число отрицательным (начинается ли строка с символа минус).

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& num}: Число для проверки.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{bool}: \texttt{true}, если число отрицательное, иначе \texttt{false}. 
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация isNegative()}]
bool BigArithmeticCalc::isNegative(const string& num) const {
    return ! num.empty() && num[0] == '-';
}
\end{lstlisting}

\subsubsection{Метод removeSign(const string\& num)}

\textbf{Назначение:} Удаляет знак минус из начала строки, возвращая абсолютное значение числа.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& num}: Число (возможно, с минусом).
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}:  Число без знака.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация removeSign()}]
string BigArithmeticCalc::removeSign(const string& num) const {
    if (isNegative(num)) {
        return num.substr(1);
    }
    return num;
}
\end{lstlisting}

\newpage

\subsubsection{Метод addSign(const string\& num, bool negative)}

\textbf{Назначение:} Добавляет знак минус к числу, если указан флаг отрицательности.  Нейтральный элемент по сложению всегда возвращается без знака. 

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& num}:  Число без знака.
    \item \texttt{bool negative}: Флаг отрицательности. 
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}: Число со знаком (если \texttt{negative = true}) или без знака. 
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация addSign()}]
string BigArithmeticCalc::addSign(const string& num, bool negative) const {
    if (num == small.getAdditiveIdentity()) return num;
    return negative ? "-" + num : num;
}
\end{lstlisting}

\subsubsection{Метод isValidNumber(const string\& num)}

\textbf{Назначение:} Проверяет, что все символы числа принадлежат алфавиту системы.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& num}: Число для проверки.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{bool}: \texttt{true}, если все символы валидны, иначе \texttt{false}.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация isValidNumber()}]
bool BigArithmeticCalc::isValidNumber(const string& num) const {
    if (num.empty()) return false;
    
    string unsign_num = removeSign(num);
    
    for (char c : unsign_num) {
        if (!small.isValidElement(string(1, c))) return false;
    }
    return true;
}
\end{lstlisting}

\subsubsection{Метод isOverflow(const string\& num)}

\textbf{Назначение:} Проверяет, не превышает ли количество разрядов числа максимально допустимое значение (MAX\_DIGITS = 8).

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& num}: Число для проверки. 
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{bool}: \texttt{true}, если произошло переполнение, иначе \texttt{false}.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация isOverflow()}]
bool BigArithmeticCalc::isOverflow(const string& num) const {
    string unsign_num = removeSign(num);
    string withoutZeros = deleteTrashZeros(unsign_num);
    return withoutZeros.length() > static_cast<size_t>(small.getMaxDigits());
}
\end{lstlisting}

\newpage

\subsubsection{Метод deleteTrashZeros(const string\& num)}

\textbf{Назначение:} Удаляет ведущие нули из числа.  Если число состоит только из нулей, возвращает нейтральный элемент по сложению.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& num}: Число с возможными ведущими нулями. 
\end{itemize}

\textbf{Выход: }
\begin{itemize}
    \item \texttt{string}: Число без ведущих нулей.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация deleteTrashZeros()}]
string BigArithmeticCalc::deleteTrashZeros(const string& num) const {
    if (num.empty()) return small.getAdditiveIdentity();
    
    bool negative = isNegative(num);
    string unsign_num = removeSign(num);
    
    size_t firstNonZero = 0;
    while (firstNonZero < unsign_num.length() && 
           string(1, unsign_num[firstNonZero]) == small.getAdditiveIdentity()) {
        firstNonZero++;
    }
    
    if (firstNonZero == unsign_num.length()) {
        return small.getAdditiveIdentity();
    }
    
    string result = unsign_num.substr(firstNonZero);
    
    return addSign(result, negative);
}
\end{lstlisting}

Алгоритм: 
\begin{enumerate}
    \item Удаляется знак (если есть);
    \item Подсчитывается количество ведущих нулей;
    \item Если все символы - нули, возвращается нейтральный элемент;
    \item Иначе возвращается подстрока без ведущих нулей со знаком (если необходимо).
\end{enumerate}

\subsubsection{Метод compareBigUnsigned(const string\& a, const string\& b)}

\textbf{Назначение:} Сравнивает два беззнаковых многозначных числа.

\textbf{Вход: }
\begin{itemize}
    \item \texttt{const string\& a}: Первое число.
    \item \texttt{const string\& b}: Второе число.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{int}: $0$ (если $a = b$), $1$ (если $a > b$), $-1$ (если $a < b$).
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация compareBigUnsigned()}]
int BigArithmeticCalc::compareBigUnsigned(const string& a, const string& b) const {
    string na = deleteTrashZeros(a);
    string nb = deleteTrashZeros(b);
    
    if (na.length() != nb.length()) {
        return na.length() > nb.length() ? 1 : -1;
    }
    
    for (size_t i = 0; i < na.length(); ++i) {
        int cmp = small.compareElems(string(1, na[i]), string(1, nb[i]));
        if (cmp != 0) return cmp;
    }
    
    return 0;
}
\end{lstlisting}

Алгоритм: 
\begin{enumerate}
    \item Нормализация чисел (удаление ведущих нулей);
    \item Сравнение по количеству разрядов;
    \item При равной длине - посимвольное сравнение слева направо. 
\end{enumerate}

\newpage

\subsection*{Операции большой арифметики}

\subsubsection{Метод addBigUnsigned(const string\& a, const string\& b)}

\textbf{Назначение:} Выполняет сложение двух беззнаковых многозначных чисел столбиком с учётом переноса между разрядами.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}: Первое слагаемое.
    \item \texttt{const string\& b}: Второе слагаемое.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}:  Сумма $a + b$ без ведущих нулей. 
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация addBigUnsigned()}]
string BigArithmeticCalc::addBigUnsigned(const string& a, const string& b) const { 
    if (!isValidNumber(a) || !isValidNumber(b)) {
        return "ERR: invalid number";
    }
    
    string num1 = a;
    string num2 = b;

    // добавляем нули
    size_t max_len = max(num1.length(), num2.length());
    while (num1.length() < max_len) {
        num1 = small.getAdditiveIdentity() + num1;
    }
    while (num2.length() < max_len) {
        num2 = small.getAdditiveIdentity() + num2;
    }

    string result;
    string carry = small.getAdditiveIdentity();

    for (int i = static_cast<int>(max_len) - 1; i >= 0; --i) {
        string digit1(1, num1[i]);
        string digit2(1, num2[i]);

        auto res = small.addWithCarry(digit1, digit2, carry);
        if (res.first == "ERR") {
            return "ERR: invalid addition";
        }
        
        string sum = res.first;
        carry = res.second;
        
        result = sum + result;
    }

    if (carry != small.getAdditiveIdentity()) {
        result = carry + result;
    }

    if (isOverflow(result)) {
        return "ERR: overflow";
    }

    return deleteTrashZeros(result);
}
\end{lstlisting}

Алгоритм выполняет сложение справа налево (от младших разрядов к старшим), используя таблицу \texttt{additionTableWithCarry} для учёта переносов.

\subsubsection{Метод subtractBigUnsigned(const string\& a, const string\& b)}

\textbf{Назначение:} Выполняет вычитание двух беззнаковых многозначных чисел столбиком с учётом заимствования из старших разрядов.  Требует, чтобы $a \geq b$.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}: Уменьшаемое ($a \geq b$).
    \item \texttt{const string\& b}: Вычитаемое. 
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}: Разность $a - b$ без ведущих нулей.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация subtractBigUnsigned()}]
string BigArithmeticCalc::subtractBigUnsigned(const string& a, const string& b) const {
    if (!isValidNumber(a) || !isValidNumber(b)) {
        return "ERR: invalid number";
    }
    
    // сравниваем числа
    int cmp = compareBigUnsigned(a, b);
    if (cmp == 0) {
        return small.getAdditiveIdentity();
    }
    
    // определяем большее и меньшее число
    string larger = (cmp >= 0) ? a : b;
    string smaller = (cmp >= 0) ? b : a;

    // выравниваем длины
    size_t max_len = max(larger.length(), smaller.length());
    while (larger.length() < max_len) {
        larger = small.getAdditiveIdentity() + larger;
    }
    while (smaller.length() < max_len) {
        smaller = small.getAdditiveIdentity() + smaller;
    }

    string result;
    bool borrow = false; // флаг заема

    // вычитаем справа налево
    for (int i = static_cast<int>(max_len) - 1; i >= 0; --i) {
        string current(1, larger[i]);
        string digit2(1, smaller[i]);
        
        if (borrow) {
			if (current == small.getAdditiveIdentity()) {
                current = small.getAlphabet().back();
            } else {
                current = small.smallSubtract(current, small.getMultiplicativeIdentity());
                borrow = false;
            }
        }
        
        int cmp_digits = small.compareElems(current, digit2);
        
        if (cmp_digits >= 0) {
            string result_digit = small.smallSubtract(current, digit2);
            result = result_digit + result;
        } else {
            string temp = current; // аналог 10 + a (если нужem заем)
            for (int j = 0; j < small.getN(); j++) {
                temp = small.nextElem(temp);
            }

            // теперь вычетаем
            string result_digit = small.smallSubtract(temp, digit2);
            result = result_digit + result;
            borrow = true; // флаг
        }
    }
    if (borrow) {
        return "ERR: borrow after subtraction";
    }
    return deleteTrashZeros(result);
}
\end{lstlisting}

Алгоритм:
\begin{enumerate}
	\item Сравниваем числа, чтобы определить, какое больше, и выравниваем их по длине добавлением ведущих нулей.

\item Вычитаем цифры поразрядно, начиная с младших разрядов, учитывая заем при необходимости.

\item Если текущая цифра меньше вычитаемой, берем заем у старшего разряда и корректируем результат.

\item Формируем итоговую строку результата и убираем ведущие нули.
\end{enumerate} 


\subsubsection{Метод multiplyBigUnsigned(const string\& a, const string\& b)}

\textbf{Назначение:} Выполняет умножение двух беззнаковых многозначных чисел столбиком.  Число $a$ умножается на каждую цифру числа $b$, промежуточные результаты сдвигаются и суммируются.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}: Множитель.
    \item \texttt{const string\& b}: Множитель.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}: Произведение $a \times b$ без ведущих нулей.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация multiplyBigUnsigned()}]
string BigArithmeticCalc::multiplyBigUnsigned(const string& a, const string& b) const {
    if (!isValidNumber(a) || !isValidNumber(b)) {
        return "ERR: invalid number";
    }
    
    if (a == small.getAdditiveIdentity() || b == small.getAdditiveIdentity()) {
        return "[" + getMinNumber() + ";" + getMaxNumber() + "]";
    }
    
    string result = small.getAdditiveIdentity();
    
    // умножение столбиком: проходим по каждой цифре множителя справа налево
    for (int i = b.length() - 1; i >= 0; --i) {
        string multiplier_digit(1, b[i]);
        
        if (multiplier_digit != small.getAdditiveIdentity()) {
            string partial_product = multiplyByDigit(a, multiplier_digit);
            if (partial_product.substr(0, 4) == "ERR:") return partial_product;
            
            // сдвиг влево (добавляем нули справа)
            int shift_count = b.length() - 1 - i;
            for (int j = 0; j < shift_count; j++) {
                partial_product += small.getAdditiveIdentity();
            }
            
            result = addBigUnsigned(result, partial_product);
            if (result.substr(0, 4) == "ERR:") return result;
        }
    }
    
    return deleteTrashZeros(result);
}

\end{lstlisting}

Алгоритм: 
\begin{enumerate}
    \item Умножение числа $a$ на каждую цифру числа $b$;
    \item Сдвиг промежуточных результатов влево на соответствующее количество разрядов;
    \item Суммирование всех промежуточных результатов. 
\end{enumerate}

\subsubsection{Метод multiplyByDigit(const string\& num, const string\& digit)}

\textbf{Назначение:} Умножает многозначное число на однозначное число (один элемент алфавита). Используется в методе \texttt{multiplyBigUnsigned}.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& num}: Многозначное число.
    \item \texttt{const string\& digit}:  Однозначное число (элемент алфавита).
\end{itemize}

\textbf{Выход: }
\begin{itemize}
    \item \texttt{string}: Произведение $num \times digit$. 
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация multiplyByDigit()}]
string BigArithmeticCalc::multiplyByDigit(const string& num, const string& digit) const {
    if (digit == small.getAdditiveIdentity()) return small.getAdditiveIdentity();
    if (digit == small.getMultiplicativeIdentity()) return num;
    
    string result = small.getAdditiveIdentity();
    string counter = small.getAdditiveIdentity();
    
    // умножаем через многократное сложение с буквенным счетчиком
    while (counter != digit) {
        result = addBigUnsigned(result, num);
        if (result.substr(0, 4) == "ERR:") return result;
        counter = small.nextElem(counter);
    }
    
    return result;
}
\end{lstlisting}

% TODO: написать алгоритм

\newpage

\subsubsection{Метод divideBigUnsigned(const string\& a, const string\& b)}

\textbf{Назначение:} Выполняет деление двух беззнаковых многозначных чисел "уголком".  Возвращает частное и остаток.

\textbf{Вход: }
\begin{itemize}
    \item \texttt{const string\& a}: Делимое.
    \item \texttt{const string\& b}: Делитель ($b \neq 0$).
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{pair<string, string>}: Пара (частное, остаток).
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация divideBigUnsigned()}]
pair<string, string> BigArithmeticCalc::divideBigUnsigned(const string& a, const string& b) const {
    if (!isValidNumber(a) || !isValidNumber(b)) {
        return {"ERR", "ERR"};
    }
    
    // деление на ноль
    if (b == small.getAdditiveIdentity()) {
        // 0/0 = [min;max]
        if (a == small.getAdditiveIdentity()) {
            return {small.getUniversum(), small.getUniversum()};
        }
        return {small.getEmptySet(), small.getEmptySet()};
    }
    
    // если делимое равно нулю
    if (a == small.getAdditiveIdentity()) {
        return {small.getAdditiveIdentity(), small.getAdditiveIdentity()};
    }
    
    string dividend = a;
    string divisor = b;
    
    // если делимое меньше делителя
    if (compareBigUnsigned(dividend, divisor) < 0) {
        return {small.getAdditiveIdentity(), dividend};
    }
    
    // деление в столбик
    string q_str;
    string curr_r = small.getAdditiveIdentity();
    
    // проходим по каждой цифре делимого слева направо
    for (size_t i = 0; i < dividend.length(); i++) {
        // добавляем следующую цифру к остатку
        curr_r = curr_r + string(1, dividend[i]);
        curr_r = deleteTrashZeros(curr_r);
        
        // ищем максимальную цифру частного
        string q_digit = small.getAdditiveIdentity();
        
        // пробуем все возможные цифры от 1 до максимальной
        string test_digit = small.getMultiplicativeIdentity();
        while (test_digit != small.getAdditiveIdentity()) {
            string test_product = multiplyByDigit(divisor, test_digit);
            
            if (compareBigUnsigned(test_product, curr_r) > 0) {
                break;
            }
            
            q_digit = test_digit;
            test_digit = small.nextElem(test_digit);
        }
        
        q_str += q_digit;
        
        // вычитаем произведение из остатка
        if (q_digit != small.getAdditiveIdentity()) {
            string product = multiplyByDigit(divisor, q_digit);
            curr_r = subtractBigUnsigned(curr_r, product);
        }
    }
    
    string q = deleteTrashZeros(q_str);
    string r = deleteTrashZeros(curr_r);
    
    return {q, r};
}

\end{lstlisting}

Алгоритм выполняет деление "уголком", последовательно вычитая делитель из текущего остатка.

\subsection*{Публичные операции с учётом знаков}

\subsubsection{Метод add(const string\& a, const string\& b)}

\textbf{Назначение: } Выполняет сложение двух чисел с учётом знаков. Обрабатывает случаи сложения чисел с одинаковыми и разными знаками.

\textbf{Вход: }
\begin{itemize}
    \item \texttt{const string\& a}: Первое слагаемое. 
    \item \texttt{const string\& b}: Второе слагаемое.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}: Сумма $a + b$ со знаком.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация add()}]
string BigArithmeticCalc::add(const string& a, const string& b) const {
    bool neg_a = isNegative(a);
    bool neg_b = isNegative(b);
    
    string unsign_a = removeSign(a);
    string unsign_b = removeSign(b);
    
    // a + b (оба положительные)
    if (!neg_a && !neg_b) {
        return addBigUnsigned(unsign_a, unsign_b);
    }
    
    // -a + (-b) = -(a + b)
    if (neg_a && neg_b) {
        string sum = addBigUnsigned(unsign_a, unsign_b);
        if (sum.substr(0, 4) == "ERR:") return sum;
        return addSign(sum, true);
    }
    
    // a + (-b) = a - b
    if (!neg_a && neg_b) {
        int cmp = compareBigUnsigned(unsign_a, unsign_b);
        if (cmp >= 0) {
            return subtractBigUnsigned(unsign_a, unsign_b);
        } else {
            string diff = subtractBigUnsigned(unsign_b, unsign_a);
			cout << "Debug:" << diff << endl;
            return addSign(diff, true);
        }
    }
    
    // -a + b = b - a
    if (neg_a && !neg_b) {
        int cmp = compareBigUnsigned(unsign_b, unsign_a);
        if (cmp >= 0) {
            return subtractBigUnsigned(unsign_b, unsign_a);
        } else {
            string diff = subtractBigUnsigned(unsign_a, unsign_b);
            return addSign(diff, true);
        }
    }
    
    return "ERR: unknown case";
}
\end{lstlisting}

Алгоритм: 
\begin{enumerate}
    \item Определяем знаки чисел и отделяем их абсолютные значения.

\item Если оба числа положительные, складываем их напрямую.

\item Если оба числа отрицательные, складываем их абсолютные значения и присваиваем результату знак минус.

\item Если одно число отрицательное, а другое положительное, выполняем вычитание меньшего числа из большего и присваиваем результату знак числа с большим абсолютным значением.

\item Возвращаем ошибку в случае некорректного входа или непредвиденной ситуации. 
\end{enumerate}


\subsubsection{Метод subtract(const string\& a, const string\& b)}

\textbf{Назначение:} Выполняет вычитание двух чисел с учётом знаков. Сводится к сложению с противоположным числом:  $a - b = a + (-b)$.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}: Уменьшаемое.
    \item \texttt{const string\& b}: Вычитаемое.
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}: Разность $a - b$ со знаком.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация subtract()}]
string BigArithmeticCalc::subtract(const string& a, const string& b) const {
    string neg_b = isNegative(b) ? removeSign(b) : "-" + b;
    return add(a, neg_b);
}
\end{lstlisting}

\subsubsection{Метод multiply(const string\& a, const string\& b)}

\textbf{Назначение:} Выполняет умножение двух чисел с учётом знаков.  Знак результата определяется правилом: $(-) \times (-) = (+)$, $(+) \times (-) = (-)$, $(+) \times (+) = (+)$.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}:  Множимое.
    \item \texttt{const string\& b}: Множитель. 
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}: Произведение $a \times b$ со знаком.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация multiply()}]
string BigArithmeticCalc::multiply(const string& a, const string& b) const {
    bool neg_a = isNegative(a);
    bool neg_b = isNegative(b);
    
    string unsign_a = removeSign(a);
    string unsign_b = removeSign(b);
    
    string product = multiplyBigUnsigned(unsign_a, unsign_b);
    if (product.substr(0, 4) == "ERR:") return product;
    
    // результат отрицательный, если знаки разные
    bool result_negative = (neg_a != neg_b);
    
    return addSign(product, result_negative);
}
\end{lstlisting}


\subsubsection{Метод divide(const string\& a, const string\& b)}

\textbf{Назначение: } Выполняет деление двух чисел с учётом знаков. Возвращает частное и остаток.

\textbf{Вход:}
\begin{itemize}
    \item \texttt{const string\& a}:  Делимое.
    \item \texttt{const string\& b}: Делитель ($b \neq 0$).
\end{itemize}

\textbf{Выход:}
\begin{itemize}
    \item \texttt{string}: Частное $a / b$ со знаком и остаток.
\end{itemize}

\begin{lstlisting}[style=cstyle, caption={Реализация divide()}]
string BigArithmeticCalc::divide(const string& a, const string& b) const {
    bool neg_a = isNegative(a);
    bool neg_b = isNegative(b);

    string unsign_a = removeSign(a);
    string unsign_b = removeSign(b);
    
    auto [q, r] = divideBigUnsigned(unsign_a, unsign_b);
    
    // обработка специальных случаев
    if (q == small.getEmptySet() || q == small.getUniversum()) {
        return "Q: " + q + " | R: " + r;
    }
    
    if (q.substr(0, 3) == "ERR") {
        return q;
    }
    
    // если делимое отрицательное, а делитель положительный
    // то -a / b = -(a/b + 1), остаток = b - r
    if (neg_a && !neg_b && r != small.getAdditiveIdentity()) {
        // добавляем единицу к частному
        q = addBigUnsigned(q, small.getMultiplicativeIdentity());
        // вычисляем новый остаток: b - r
        r = subtractBigUnsigned(unsign_b, r);
        q = addSign(q, true);
    }
    // если делимое положитmельное, а делитель отрицательный
    // то a / (-b) = -(a/b), остаток остается r
    else if (!neg_a && neg_b) {
        q = addSign(q, true);
    } else if (neg_a && !neg_b) { // -a / b = -(a/b) без остатка
        q = addSign(q, true);
    }
    // если оба отрицательные: -a / (-b) = a/b
    else if (neg_a && neg_b) {}
    
    return "Q: " + q + " | R: " + r;
}
\end{lstlisting}

Алгоритм:
\begin{enumerate}
	\item Вычисляем частное и остаток для абсолютных значений чисел.


\item	Корректируем знак частного и остатка в зависимости от знаков делимого и делителя.


\item Возвращаем результат в формате "Q: <частное> | R: <остаток>".
\end{enumerate}

\newpage